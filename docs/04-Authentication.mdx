# Authentication

In the following section we make an introduction to the technical specification and usage of our authentication system. 

## Introduction 
We make use of authentication for two reasons - simulate the usage of the Single Sign on from DTU and rate limiting. 
The latter will be specified in its own section. 

## Types of security
[Spring security](https://docs.spring.io/spring-security/reference/index.html) contains many methods for securing an application. We make use of libraries to be consistant with the usage of Spring Boot, 
but an added benefit is the fact that their implementation is better and more secure compared to what we would be able to write ourselves. 

Specified in the Datbase section we make us of a simple SQL server to handle our users and their permissions - which is being used by [JDBC Connection](https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/jdbc.html) to handle authentication. 
This includes hashing passwords and adding salt. This is done using the ```BCRYPT Algorithm```.

The security type we define is based on sessions. Meaning that once a user is verified they are authorized temporarily using a session Cookie. 
Upon expiration the user would have to sign in again. 
:::caution
``` Spring Security 3.1.1``` has no support for setting the SamSite cookie attribute used to handle CSRF. 
To get around this the attribute is set in Nginx. 
:::


## The security chain
All requests in the application goes through the ```Security Filter Chain``` in the backend. 
In here we define which REST API endpoints are allowed without being authorised. 
To add more endpoints to the filter chain or in general change the security config edit the  ```SecurityConfig``` file. 

```java
/*
    |
    |
    |
    |
*/
 return http
                .csrf((csrf) -> csrf
                        .csrfTokenRepository(tokenRepository)
                        .csrfTokenRequestHandler(requestHandler)
                )
                .httpBasic((basic) -> basic
                        // Custom response header to avoid default browser login behavior
                        .authenticationEntryPoint(new LoginEntryPoint())
                        .addObjectPostProcessor(new ObjectPostProcessor<BasicAuthenticationFilter>() {
                            @Override
                            public <O extends BasicAuthenticationFilter> O postProcess(O filter) {
                                filter.setSecurityContextRepository(httpSessionSecurityContextRepository);
                                return filter;
                            }
                        }))
                .authorizeHttpRequests((requests) -> requests
                        .requestMatchers(HttpMethod.POST, "/api/login/login", "/api/login/recover", "/api/login/register", "/api/login/recover").permitAll()
                        .requestMatchers(HttpMethod.PUT, "/api/login/verify", "/api/login/newPassword").permitAll()
                        .requestMatchers(HttpMethod.GET, "/api/csrf", "/api/login/logout", "/api/breaches/all").permitAll()
                        .anyRequest().authenticated()
                )
                .logout(logout -> logout
                        .logoutUrl("/api/logout")
                        .invalidateHttpSession(true)
                        .logoutSuccessUrl("/api/csrf")
                )
                .build()
                ;
```

In the code snippet above we define the implementation of the ```Security Filter Chain```. 
Initially we enable CrossSiteRequestForgery of which we add the [HTTP basic](https://swagger.io/docs/specification/authentication/basic-authentication/) authentication type. 

We define a new entrypoint ```LoginEntryPoint``` to disable build in ```WWW-Authentication``` headers and status codes from browsers disabling default forms. 
:::info
```java
 @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authEx) throws IOException {
        response.addHeader("X-CUSTOM-AUTHENTICATE", "Basic realm=\"" + getRealmName() + "\"");
        response.addHeader("Content-Type", "text/html; charset=utf-8");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        PrintWriter writer  = response.getWriter();
        writer.println("HTTP Status 401 - " + authEx.getMessage());
    }
```
Construction of the custom response to the ```LoginEntryPoint```.
:::

Lastly we define the ```authorizedHttpRequests``` on a request *TYPE* basis, i.e,, POST, PUT and GET and their endpoints allowed without authoirsation. 
If any other endpoint is reached they are met with the ```LoginEntryPoint``` request headers and redirected to the Sign in page. 

Similarily we ensure that the ```Security Filter Chain``` listens for any HTTP basic logout type to sign the user out and revoke a session token. 


## Default usage
Per default no users are added - This means there are currently no users with the ```Admin``` user role.
In future versions a great implementation would be to implement a user panel allowing users to edit their information, and perhabs upload data if they had a certain role. 
:::tip
Implementation of user roles may be added with SSO (Single Sign on) of DTU
:::

